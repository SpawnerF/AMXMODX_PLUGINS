/* Plugin generated by AMXX-Studio */

#include <amxmodx>
#include <amxmisc>
#include <hamsandwich>
#include <ColorChat>
#include <xs>

#define PLUGIN "Revive menu"
#define VERSION "1.0"
#define AUTHOR "Spawner"

#define Revive. _rev_

new bool:autoRevive

new playerInfo[ 256 ];
new countRevive[ 33 ];

new const _rvMenuItems[][] = 
{
	"Revive all",
	"Revive all Terro",
	"Revive all CT",
	"Revive One player"
};

public plugin_init() {
	
	register_plugin(PLUGIN, VERSION, AUTHOR);
	
	register_clcmd( "say /revive", "hook_ReviveMenu");
	
	RegisterHam(Ham_Killed, "player", "player_Killed");
	register_menucmd();
}

public player_Killed( indexVic )
{
	if( autoRevive )
		set_task( 0.5, "spawn_Player", indexVic );
}

public spawn_Player( id ) ExecuteHamB( Ham_CS_RoundRespawn, id );

public hook_ReviveMenu( index )
{
	if( strlen(playerInfo) <= 0 ) playerInfo = "None";
	
	if( ~get_user_flags( index ) & ADMIN_BAN )
	{
		ColorChat( index, GREY, "^4[(c)Spawner)] ^1You don't have access to this ^3menu." );
		return PLUGIN_HANDLED;
	}	
	
	new _reviveMenu = menu_create( "\d[(c) Spawner )] \rRevive menu", "menu_display_hook");
	menu_additem( _reviveMenu, strconcat( "Auto revive : ", autoRevive ? "\r[ON]" : "\d[OFF]", "\y[", playerInfo, "\y]" ));
	
	for (new i; i < sizeof _rvMenuItems; i++)
	{
		//replace( _rvMenuItems[i], 124, "%status%", autoRevive ? "\r[ON]" : "\d[OFF]" );
		menu_additem( _reviveMenu, _rvMenuItems[i] );
	}	
	
	menu_display(index, _reviveMenu);
	
	return PLUGIN_CONTINUE;
}

public menu_display_hook( id, Menu, item )
{
	if( item == MENU_EXIT )
	{
		return PLUGIN_HANDLED;
	}
	
	switch(item)
	{
		case 0:
		{
			new _userName[ 32 ];
			get_user_name( id, _userName, charsmax( _userName ));
			
			autoRevive = !(autoRevive);
			playerInfo = strconcat( "\w", autoRevive ? "Activated by : \r" : "Desactivated by : \r", _userName);

			hook_ReviveMenu(id);
		}
		case 1:
		{
			reviveTeam();
		}
		case 2:
		{
			reviveTeam( "TERRORIST");
		}
		case 3:
		{
			reviveTeam( "CT");	
		}
		case 4:
		{
			Revive.player(id);
		}
	}
	
	return PLUGIN_CONTINUE;
}

Revive.player(id)
{
	
	new _terroMenu = menu_create( "\d[(c) Spawner )] \rRevive menu \r[Terro]", "menu_display_hook_t");
	
	new countPlayers[ 32 ], i, pIndex;
	get_players( countPlayers, i, "bc" );
		
	for (new player; player < i; player++ )
	{
		pIndex = countPlayers[player];
		
		static getName[32];
		get_user_name(pIndex, getName, charsmax(getName));
		
		menu_additem(_terroMenu, getName);
	}
	
	menu_display(id, _terroMenu);		
}

public menu_display_hook_t(id, Menu, item)
{
	if( item == MENU_EXIT )
	{
		menu_destroy( Menu ) 
		return PLUGIN_HANDLED;
	}
	
	new iData[ 6 ], acces, callback 
	menu_item_getinfo( Menu, item, acces, iData, 5, szName, 32, callback ) 
    
	new iTarget = str_to_num( iData );
	if( !is_user_alive( iTarget ) ) 
	{ 
 		ExecuteHamB( Ham_CS_RoundRespawn, iTarget ) 
	}
}

stock reviveTeam( const team[] = "" )
{
	
	new countPlayers[ 32 ], i, pIndex
	get_players( countPlayers, i, "bce", team )
		
	for (new player; player < i; player++ )
	{
	
		pIndex = countPlayers[player];
		ExecuteHamB(Ham_CS_RoundRespawn, pIndex);
	}	
	
}
stock strconcat(...)
{
	new str[256];
	new it, NumArgs = numargs();
	for (new idx, ch; it < (sizeof(str) - 1) && idx < NumArgs; idx++)
	{
		new index;
		while ( it < (sizeof(str) - 1) && ( ch = getarg( idx, index++ ) ) != 0 )
			str[it++] = ch;
	}
	str[it] = 0;
	
	#emit LOAD.S.PRI 0x8
	#emit ADDR.ALT 0xC
	#emit ADD
	#emit LOAD.I
	#emit MOVE.ALT
	#emit ADDR.PRI str
	#emit MOVS 0x400
	#emit STACK 0x408
	#emit RETN
	
	return str;
}